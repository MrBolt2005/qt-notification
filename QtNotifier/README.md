### QtCrossNotifierExample
Пример кроссплатформенного модуля для Qt/QML. 

### Пример использования
```
notification.show({
                      caption: "hello",
                      title  : "notification",
                      id     : 0
                  });
```

### Архитектура

*Базовый абстрактный компонент нотификации (`QtAbstractNotifyer.h`)*

Нужен для того, чтобы определить API для компонента, этот API и будет использоваться в QML
На основе этого компонента создаются платформеннозависимые классы, которые являются связующим звеном с API целевой платформы.

Соответственно вот эти классы: `QtAndroidNotifyer`, `QtIosNotifyer`, `QtMacOsNotifyer`. Каждый из этих классов наследует `QtAbstractNotifyer` и перереопределяет, если это необходимо, его методы.

*Фабрика*

Необходимо определить тот класс (из списка перечисленных выше), с которым приложение будет работать на текущей платформе, с этой целью существует фабрика `QtNotifyerFactory`

*Qml wrapper*

Для того, чтобы иметь возможность использовать компонент в QML, агрегируем `QtAbstractNotifyer`, который, при инициализации обертки, будет инстанциирован фабрикой `QtNotifyerFactory`. Плюс, для удобства добавлен статический метод, который регестрирует тип (qmlRegisterType). В результате имеет корневой класс `QtNotification`.

*Есть еще одна проблема, связанная с тем, что на разных платформах на вход API подаются разные данные*

Например в android, чтобы создать уведомление нужно предать id уведомления, по которому его потом можно закрыть, в iOS и mac он не нужен. 
Такая проблема решается передачей параметров в виде QVariantMap, который из QML передается как обычный jsobject. В таком случае, мы можем игнорировать ненужные параметры в платформеннозависимом коде.





